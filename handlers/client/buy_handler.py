import json
import random
import logging as lg
import pymongo
import aiohttp
# from services.payment import cloudpay_api, cryptobot_api
from aiogram.types import CallbackQuery, Message, InlineKeyboardButton
import asyncio
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder

from keyboards.client_kb import kb
from config_data.create_bot import db
from utils.func import get_text, report, current_time, check_donate_sub
from config_data.config import config
from config_data.config_load import pay_list
from config_data.create_bot import bot, dp, db


async def crypto_check_payment(call: CallbackQuery):
    data = call.data.split('_')
    buy_type = data[2]
    track_id = data[3]
    if await cryptobot_api.check(track_id) or call.from_user.id in config["AdminList"]:
        await accrual_requests(call, buy_type)
    else:
        await call.answer("‚ùå–°—á–µ—Ç –Ω–µ –±—ã–ª –æ–ø–ª–∞—á–µ–Ω!")


async def ym_check_payment(call: CallbackQuery):
    data = call.data.split('_')
    buy_type = data[2]
    track_id = data[3]
    payinfo = await cloudpay_api.check(track_id, buy_type)
    lg.info(payinfo)
    if payinfo is not None:
        await accrual_requests(call, buy_type, payinfo[1], payinfo[2], payinfo[3])
    else:
        await call.answer("‚ùå–°—á–µ—Ç –Ω–µ –±—ã–ª –æ–ø–ª–∞—á–µ–Ω!")


async def accrual_requests(buy_type, chatid, token=None, invoice=None, subid = None):
    chat_id = chatid
    mongoclient = pymongo.MongoClient(f"mongodb://{config['MongoDBHost']}:{config['MongoDBPort']}/")
    mydb = mongoclient["payments"]
    sub = mydb["subscribtions"]
    userdata = {"_id": str(chat_id)}
    usercol = sub.find_one(str(chat_id))
    if usercol is None:
        sub.insert_one(userdata)

    if pay_list[buy_type]["course"]:
        text = f"<b>üí´ –ü–æ–∑–¥—Ä–∞–≤–ª–µ–º! –û—Ñ–æ—Ä–º–ª–µ–Ω–∞ {pay_list[buy_type]['message_text']}!</b>\n\n" \
               f"–í—ã —É–∂–µ —Å–µ–π—á–∞—Å –º–æ–∂–µ—Ç–µ –ø—Ä–æ–π—Ç–∏ –Ω–∞—à–µ –æ–±—É—á–µ–Ω–∏–µ –ø–æ <a href='{config['EducationUrl']}'>–¥–∞–Ω–Ω–æ–π —Å—Å—ã–ª–∫–µ.</a>\n" \
               f"–ê —á—Ç–æ–±—ã –∏—Å–ø—ã—Ç–∞—Ç—å –º–µ–Ω—é –ø—Ä–æ–º–ø—Ç–æ–≤, –ø–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ –∫–Ω–æ–ø–∫–µ\n<b>{get_text('buts.profile')}!</b>"
    else:
        text = f"<b>üí´ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –û—Ñ–æ—Ä–º–ª–µ–Ω–∞ {pay_list[buy_type]['message_text']}!</b>"

    course = True if db.read(chat_id, 'course') else pay_list[buy_type]["course"]
    donate = pay_list[buy_type]["callback_text"]
    expired_time = pay_list[buy_type]["expired_time"]
    expired_time = current_time(expired_time)

    requests_gpt = pay_list[buy_type]["requests_gpt"]
    requests_gpt = db.read(chat_id, "requests_gpt") + requests_gpt
    requests_mj = pay_list[buy_type]["requests_mj"]
    requests_mj = db.read(chat_id, "requests_mj") + requests_mj
    requests_pikalabs = pay_list[buy_type]["requests_pikalabs"]
    requests_pikalabs = db.read(chat_id, 'requests_pikalabs') + requests_pikalabs
    requests_deepai = pay_list[buy_type]["requests_deepai"]
    requests_deepai = db.read(chat_id, 'requests_deepai') + requests_deepai
    requests_dalle = pay_list[buy_type]["requests_dalle"]
    requests_dalle = db.read(chat_id, 'requests_dalle') + requests_dalle

    if pay_list[buy_type]["product_type"] == "subscribe":
        if pay_list[buy_type]["type"] == "mj+gpt":

            db.update(chat_id, 'expired_time', expired_time)
            db.update(chat_id, 'premium_type', buy_type)
        elif pay_list[buy_type]["type"] == "zeroscope":
            db.update(chat_id, 'expired_time_pika', expired_time)
            db.update(chat_id, 'premium_type_pika', buy_type)
        else:
            db.update(chat_id, f'expired_time_{pay_list[buy_type]["type"]}', expired_time)
            db.update(chat_id, f'premium_type_{pay_list[buy_type]["type"]}', buy_type)
        # if invoice and token is not None:
        #     db.update(chat_id, 'invoiceid', invoice)
        #     db.update(chat_id, 'cardtoken', token)
        #     db.update(chat_id, 'subid', subid)
        # else:
        #     pass

        if subid is not None:
            try:
                usersubid = usercol[f"subid_{pay_list[buy_type]['type']}"]
                if usersubid is not None:
                    x = await subcancel(usersubid)

            except:
                pass
            newsubid = {"$set": {f"subid_{pay_list[buy_type]['type']}": subid}}
            newsub = {"$set": {pay_list[buy_type]['type']: buy_type}}
            newsubs = {"$push": { "buytypes": buy_type}}
            sub.update_one(userdata, newsubid)
            sub.update_one(userdata, newsub)
            sub.update_one(userdata, newsubs)


    db.update(chat_id, 'buyer', True)
    db.update(chat_id, 'course', course)
    db.update(chat_id, 'requests_gpt', requests_gpt)
    db.update(chat_id, 'requests_mj', requests_mj)
    db.update(chat_id, 'requests_pikalabs', requests_pikalabs)
    db.update(chat_id, 'requests_deepai', requests_deepai)
    db.update(chat_id, 'requests_dalle', requests_dalle)

    await bot.send_message(chatid, text)
    lg.error('INFORMATED')
    await report('<b>üí´ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º</b>\n\n'
                    f'Username: '
                    f'ID: <code>{chat_id}</code>\n'
                    f'–ö—É–ø–ª–µ–Ω–æ: <code>{donate}</code>',
                    config["AdminList"])


async def autoupdate(chat_id):
    buy_type = db.read(chat_id, "premium_type")
    expired_time = pay_list[buy_type]["expired_time"]
    expired_time = current_time(expired_time)
    requests_gpt = pay_list[buy_type]["requests_gpt"]
    requests_gpt = db.read(chat_id, "requests_gpt") + requests_gpt
    requests_mj = pay_list[buy_type]["requests_mj"]
    requests_mj = db.read(chat_id, "requests_mj") + requests_mj
    requests_pikalabs = pay_list[buy_type]["requests_pikalabs"]
    requests_pikalabs = db.read(chat_id, 'requests_pikalabs') + requests_pikalabs
    if pay_list[buy_type]["product_type"] == "subscribe":
        if pay_list[buy_type]['type'] == "zeroscope":
            db.update(chat_id, 'expired_time_pika', expired_time)
            db.update(chat_id, 'premium_type_pika', buy_type)
        else:
            db.update(chat_id, f'expired_time_{pay_list[buy_type]["type"]}', expired_time)
            db.update(chat_id, f'premium_type_{pay_list[buy_type]["type"]}', buy_type)

    db.update(chat_id, 'buyer', True)
    db.update(chat_id, 'requests_gpt', requests_gpt)
    db.update(chat_id, 'requests_mj', requests_mj)
    db.update(chat_id, 'requests_pikalabs', requests_pikalabs)
    promo = db.read(chat_id, "promo")
    db.admin_request(f"UPDATE promo SET used = used + 1 WHERE name '{promo}'")
    db.update(chat_id, "promo", None)



async def crypto_currency(call: CallbackQuery):
    await call.message.edit_text(
        text=get_text('text.premium_crypto'),
        reply_markup=kb.crypto_currency(call.data)
    )


async def choose_pay_crypto(call: CallbackQuery):
    chat_id = call.from_user.id
    data = call.data.split("_")

    payment_type = data[1]
    amount = pay_list[payment_type]["amount"]
    currency = data[2]

    url, track_id = await cryptobot_api.create_payment(str(chat_id), amount, currency)
    callback = f"check_crypto_{payment_type}_{track_id}"

    await call.message.edit_text(
        f'{get_text("text.pay")}\n\n'
        f'ID –û–ø–ª–∞—Ç—ã: <code>{track_id}</code>',
        reply_markup=kb.pay(callback, url, amount)
    )


async def choose_pay_ym(call: CallbackQuery):
    chat_id = call.from_user.id
    data = call.data.split("_")

    payment_type = data[1]
    track_id = str(chat_id) +  str(random.randint(1, 99999))
    promo = db.read(chat_id, "promo")
    amount = pay_list[payment_type]["amount"]
    if promo is not None:
        discount = db.admin_request(f"SELECT * FROM promo WHERE name = '{promo}'")
        amount = int(amount) - (int(amount) / 100 * int(discount[0][3]))
    payinfo = await cloudpay_api.create_payment(track_id, amount, chat_id, data[1])
    callback = f"check_ym_{payment_type}_{track_id}"

    await call.message.edit_text(
        text=f'{get_text("text.pay")}\n\n'
        f'ID –û–ø–ª–∞—Ç—ã: <code>{track_id}</code>',
        reply_markup=kb.pay(callback, payinfo, amount)
    )


async def more_about_course(call: CallbackQuery):
    await call.message.edit_text(
        text=get_text('text.premium_course'),
        reply_markup= kb.description_premium("buy-2(skip)", "buy-2")
    )


async def description_premium(call: CallbackQuery):
    buy_type = call.data.split("_")[1]
    type = call.data.split("_")[2]

    await call.message.edit_text(
        text=get_text(f'text.premium_{buy_type}'),
        reply_markup=kb.description_premium(buy_type, type)
    )


async def buy_handler(call: CallbackQuery):
    await call.message.edit_text(
        text=f"<b>üç¨ {pay_list[call.data]['message_text']}</b>\n\n"
        f"–í–∞—à ID: <code>{call.from_user.id}</code>\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ç–æ–¥ –æ–ø–ª–∞—Ç—ã üç¨",
        reply_markup=kb.buy_handler(call.data)
    )


async def call_premium(call: CallbackQuery, state: FSMContext):
    chat_id = call.from_user.id
    await state.clear()

    days = check_donate_sub(chat_id)
    if days:
        text = f"üí´ –£ –≤–∞—Å –¥–µ–π—Å—Ç–≤—É–µ—Ç –ø–æ–¥–ø–∏—Å–∫–∞, –æ—Å—Ç–∞–ª–æ—Å—å {days} –¥–Ω–µ–π!"
    else:
        text = get_text('text.premium')

    await call.message.edit_text(
        text=text,
        reply_markup=kb.premium()
    )

async def promocodes(message: Message, state: FSMContext):
    chat_id = message.from_user.id
    db.update(chat_id, "promo", None)
    await message.answer("""<i>‚ú® –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–æ–∫–æ–¥ –Ω–∞ –ø–æ–∫—É–ø–∫—É, –µ—Å–ª–∏ –æ–Ω –∏–º–µ–µ—Ç—Å—è </i>""", reply_markup=kb.promostage(), parse_mode='html')
    await state.set_state(PromoState.promo)





async def premium(message: Message, state: FSMContext):
    chat_id = message.from_user.id
    days = check_donate_sub(chat_id)
    promo = message.text


    await state.clear()

    promocode = db.admin_request(f"SELECT * FROM promo WHERE name = '{str(promo)}'")
    prinfo = ""

    if promocode is None:
        prinfo = "üòî –¢–∞–∫–æ–≥–æ –ø—Ä–æ–º–æ–∫–æ–¥–∞ –Ω–µ—Ç –≤ –Ω–∞—à–µ–π –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö"
    else:
        try:
            if int(promocode[0][2]) > int(promocode[0][1]):
                prinfo = "üòî –£ —ç—Ç–æ–≥–æ –ø—Ä–æ–º–æ–∫–æ–¥–∞ –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏–π!"
            else:
                prinfo = f"üòä –•–æ—Ä–æ—à–∏–µ –Ω–æ–≤–æ—Å—Ç–∏, –≤–∞—à –ø—Ä–æ–º–æ–∫–æ–¥ –Ω–∞ —Å—É–º–º—É {promocode[0][3]}% —É—Å–ø–µ—à–Ω–æ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!"
                db.update(chat_id, "promo", promo)
        except Exception as e:
            prinfo = "üòî –¢–∞–∫–æ–≥–æ –ø—Ä–æ–º–æ–∫–æ–¥–∞ –Ω–µ—Ç –≤ –Ω–∞—à–µ–π –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö"

    if days:
        text = f"{prinfo}\n\nüí´ –£ –≤–∞—Å –¥–µ–π—Å—Ç–≤—É–µ—Ç –ø–æ–¥–ø–∏—Å–∫–∞, –æ—Å—Ç–∞–ª–æ—Å—å {days} –¥–Ω–µ–π!"
    else:
        text = f"{prinfo}\n\n{get_text('text.premium')}"

    await message.answer(
        text=text,
        reply_markup= kb.premium()
    )


async def disable_autoups(call: CallbackQuery):
    await call.message.edit_text("‚öôÔ∏è –°–æ–±–∏—Ä–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–¥–ø–∏—Å–∫–∞—Ö, –æ–∂–∏–¥–∞–π—Ç–µ...")
    chat_id = call.from_user.id
    builder = InlineKeyboardBuilder()
    mongoclient = pymongo.MongoClient(f"mongodb://{config['MongoDBHost']}:{config['MongoDBPort']}/")
    mydb = mongoclient["payments"]
    sub = mydb["subscribtions"]
    usercol = sub.find_one(str(chat_id))
    for x in usercol['buytypes']:
        button_list = [
            InlineKeyboardButton(text=pay_list[x]['callback_text'], callback_data=f"submgt:{x}")]
        builder.add(*button_list)
        builder.adjust(1)
    await call.message.edit_text("‚¨áÔ∏è –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É –Ω–∏–∂–µ", reply_markup=builder.as_markup())

async def submanagment(call: CallbackQuery):
    mongoclient = pymongo.MongoClient(f"mongodb://{config['MongoDBHost']}:{config['MongoDBPort']}/")
    mydb = mongoclient["payments"]
    sub = mydb["subscribtions"]
    chat_id = call.from_user.id
    usercol = sub.find_one(str(chat_id))

    buytype = call.data.split(":")[1]

    tftype = pay_list[buytype]['type']
    subid = ""
    try:
        subid = usercol[f"subid_{tftype}"]
    except:
        await call.message.edit_text("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–¥–ø–∏—Å–∫–µ. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –º–µ–Ω–µ–¥–∂–µ—Ä—É.")

    url = "https://api.cloudpayments.ru/subscriptions/get"

    headers = {'content-type': 'application/json'}
    session = aiohttp.ClientSession()
    info = {
        "Id": subid
    }
    sub = []
    async with session.post(
            url, data=json.dumps(info), headers=headers,
            auth=aiohttp.BasicAuth(
                config['CPID'],
                config['CPKEY']
            )
    ) as resp:
        subinfo = await resp.json(content_type=None)
        resp.close()
        await session.close()

    if subinfo is not None:
        x = subinfo['Model']

        starttime = x['StartDateIso']
        time = x['NextTransactionDateIso']
        amount = x['Amount']
        await call.message.edit_text(f"""‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ {pay_list[buytype]['callback_text']}

‚ö°Ô∏è –î–∞—Ç–∞ —Å–ª–µ–¥—É—é—â–µ–≥–æ –ø–ª–∞—Ç–µ–∂–∞: {time.split('T')[0]} –≤ {time.split('T')[1]}

üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å –ø–æ–¥–ø–∏—Å–∫–∏: {amount}‚ÇΩ""", reply_markup=kb.submgr(x['Id'], buytype))
    else:
        await call.answer("–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞")
        return

async def submgr_disable(call: CallbackQuery):
    data = call.data.split(":")[1]
    buytype = call.data.split(":")[2]
    cancel = await subcancel(data)
    if cancel is True:
        mongoclient = pymongo.MongoClient(f"mongodb://{config['MongoDBHost']}:{config['MongoDBPort']}/")
        mydb = mongoclient["payments"]
        sub = mydb["subscribtions"]
        try:
            myquery = {"_id": str(call.from_user.id)}
            removetype = {"$pull": {"buytypes": buytype}}
            removebuytume = {"$unset": {pay_list[buytype]['type']: buytype}}
            removesubid = {"$unset": {f"subid_{pay_list[buytype]['type']}": data}}
            sub.update_one(myquery, removetype)
            sub.update_one(myquery, removebuytume)
            sub.update_one(myquery, removesubid)
            await call.message.edit_text("‚úÖ –ê–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω–æ. –°–ø–∞—Å–∏–±–æ –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ!")
        except Exception as e:
            await call.message.edit_text("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫–ª—é—á–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –º–µ–Ω–µ–¥–∂–µ—Ä—É!")
    else:
        await call.message.edit_text("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫–ª—é—á–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –º–µ–Ω–µ–¥–∂–µ—Ä—É!")


async def disable_autoup(call: CallbackQuery):
    await call.message.edit_text(
        text="""–í–Ω–∏–º–∞–Ω–∏–µ !

‚ö°Ô∏è –ü—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏ –ø–æ–¥–ø–∏—Å–∫–∏ –≤—ã –ø–æ—Ç–µ—Ä—è–π—Ç–µ –≤–∞—à –ü—Ä–µ–º–∏–º—É–º –¥–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –¥–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–∫—É–ø–∫–∏. –û—Ç–∫–ª—é—á–∏—Ç—å –¥–æ—Å—Ç—É–ø —Å–µ–π—á–∞—Å ?""",
        reply_markup=kb.auto_confirm()
    )

async def subcancel(subid):
        url = 'https://api.cloudpayments.ru/subscriptions/cancel'
        headers = { 'content-type': 'application/json' }
        session = aiohttp.ClientSession()
        subcancel = {
            "Id": subid,
        }

        async with session.post(
                url, data = json.dumps(subcancel), headers = headers,
                auth = aiohttp.BasicAuth(
                    config['CPID'],
                    config['CPKEY']
                    )
                ) as resp:
            response = await resp.json(content_type = None)

            resp.close()
            await session.close()
        return response['Success']
async def disable_autoup_off(call: CallbackQuery):
    await call.message.edit_text(
        text="üïê –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ, –ø–æ–∫–∞ –º—ã –æ—Ç–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏–µ...",
    )
    chatid = call.from_user.id
    subid = db.read(chatid, "subid")
    status = await subcancel(subid)
    if status is True:
        cardtoken = None
        invoiceid = None
        db.update(chatid, "cardtoken", cardtoken)
        db.update(chatid, 'invoiceid', invoiceid)
        db.update(chatid, 'subid', None)




        await call.message.edit_text(
            text="üòî –ê–≤—Ç–æ–ø–æ–¥–ø–∏—Å–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞!",
            reply_markup=kb.back_to_profile()
        )
    else:
        await call.message.edit_text(
            text="‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ –ø–æ–¥–ø–∏—Å–∫–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –º–µ–Ω–µ–¥–∂–µ—Ä—É.",
            reply_markup=kb.back_to_profile()
        )

async def disable_autoup_off_recursive(call: CallbackQuery):
    await call.message.edit_text(
        text="üïê –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ, –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø–æ–∏—Å–∫ –ø–æ–¥–ø–∏—Å–æ–∫...",
    )
    active = []
    url = "https://api.cloudpayments.ru/subscriptions/find"

    headers = {'content-type': 'application/json'}
    session = aiohttp.ClientSession()

    info = {
        "accountId": call.from_user.id
    }

    async with session.post(
            url, data=json.dumps(info), headers=headers,
            auth=aiohttp.BasicAuth(
                config['CPID'],
                config['CPKEY']
            )
    ) as resp:
        subinfo = await resp.json(content_type=None)
        resp.close()
        await session.close()
    for i in subinfo['Model']:

        # if i['Status'] == "Active":
            active.append(i['Id'])


    subid = db.read(call.from_user.id, "subid")
    if subid is not None:
        if subid != "":
            try:
                active.remove(subid)
            except ValueError:
                pass
    if len(active) == 0:
        await call.message.edit_text(
            text=f"‚úÖ –•–æ—Ä–æ—à–∏–µ –Ω–æ–≤–æ—Å—Ç–∏! –£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫.",
        )
    else:
        await call.message.edit_text(
            text=f"‚ö†Ô∏è –ù–∞–π–¥–µ–Ω–æ {len(active)} –ø–æ–¥–ø–∏—Å–æ–∫. –û—Ç–∫–ª—é—á–∞–µ–º...",
        )
        await asyncio.sleep(3)
        n = 0
        for x in active:
            await call.message.edit_text(
                text=f"‚ö†Ô∏è –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ. –û—Ç–∫–ª—é—á–µ–Ω–æ {n}/{len(active)} –ø–æ–¥–ø–∏—Å–æ–∫...",
            )
            url = 'https://api.cloudpayments.ru/subscriptions/cancel'
            headers = {'content-type': 'application/json'}
            session = aiohttp.ClientSession()
            subcancel = {
                "Id": x,
            }

            async with session.post(
                    url, data=json.dumps(subcancel), headers=headers,
                    auth=aiohttp.BasicAuth(
                        config['CPID'],
                        config['CPKEY']
                    )
            ) as resp:
                response = await resp.json(content_type=None)

                resp.close()
                await session.close()
            await asyncio.sleep(3)
            n = n + 1
        await call.message.edit_text(
            text=f"‚úÖ –•–æ—Ä–æ—à–∏–µ –Ω–æ–≤–æ—Å—Ç–∏! –ü–æ–¥–ø–∏—Å–æ–∫ –æ—Ç–∫–ª—é—á–µ–Ω–æ - {len(active)}",
        )


async def choose_premium(call: CallbackQuery):
    data = call.data.split(":")[1]

    if data == "zeroscope":
        text=f"<b>üéêPika Labs</b>\n\n" \
              "<i>–ù–µ–π—Ä–æ—Å–µ—Ç—å –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç\n" \
              "–≤–∞—à —Ç–µ–∫—Å—Ç–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –≤ –≤–∏–¥–µ–æ.</i>"
    elif data == "mj+gpt":
        text="‚ö°Ô∏è –í—ã–±–µ—Ä–∏—Ç–µ —Å—Ä–æ–∫ –≤–∞—à–µ–π –±—É–¥—É—â–µ–π –ø–æ–¥–ø–∏—Å–∫–∏!"
    elif data == "gpt":
        text="‚ö°Ô∏è –í—ã–±–µ—Ä–∏—Ç–µ —Å—Ä–æ–∫ –≤–∞—à–µ–π –±—É–¥—É—â–µ–π –ø–æ–¥–ø–∏—Å–∫–∏!"
    else:
        text = call.message.text

    await call.message.edit_text(
        text=text,
        reply_markup=kb.pay_list_keyboard(data, True)
    )
